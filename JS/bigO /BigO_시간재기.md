# big O 로 시간재기

```js
function dd(n) {
    let total = 0;
    for (let i = 1; i <= n; i++) {
        total += i
    }
    return total
}

console.log(dd(100))

function addUpTo2(n) {
    return n * (n + 1) / 2
}
console.log(addUpTo2(100))
```

이 두 코드를 비교하면 어떻게 되는가? 

여기서 더 나은것은 무엇인가? 

1. 속도가 빠른것으로 해야하는가요?
2. 메모리를 적게 쓰는걸로?
3. 만들어지는 변수의 갯수, 함수 호출시 저장되는것
4. 코드를 얼마나 쉽게 읽을 수 있는가?  -> 코드 적은 코드 쓰기 

아니면 이런 모든 점을 다 고려해보고 조화를 이루어야 한다., 하지만 상황마다 다르다.

보통 중요시 되는것은 1,2 번이다.

하지만 우리는 우선은 속도를 평가하는 것에 집중해야 한다.

속도를 측정하는 가장 편한 방법은 내장되어 있는 타이밍 펑션 사용하는 것이다. addUpTo


1. 타이밍 펑션
```js

function addUpTo(n) {
    let total = 0;
    for (let i = 1; i <= n; i++) {
        total += i
    }
    return total
}

let t1 = performance.now()
addUpTo(1000000000)
let t2 = performance.now()
console.log(`Time Elapsed : ${(t2 - t1) / 1000} seconds`)
```

이런 방법이 가장 좋은 방법이 아니지만 일일히 하는 방법중 하나임

이 방법에는 기기마다 다른 방법으로 시간을 잰다는 것과, 기계에 다른 무엇인가가 실행될때등 다양한 문제가 있다.

언제나 다른 시간이 적용된다는 것이 단점이다.

위 코드도 매번 다른 시간이 나오기 때문에 **완전히 믿을수 없다는 단점**이 있다.

그럼 이제 어떤 개념을 사용해야 할까요?

정확한 시간을 초로 계산하는 것보다 **연산 갯수**를 세면 된다.

ex) 알고리즘을 7개를 해야 한다면, 결국 그 7개에 시간이 걸리게 되는 것 

```js
function addUpTo(n){
    return n * (n+1) /2
}
```
위의 코드의 경우 곱셈 하나, 덧셈 하나, 나눗셈 하나가 존재한다. 이러한 행위 하나 하나를 연산개수로 친다. 

**계산(연산)은 딱 3번 이루어진다**.

```js
function addUpTo(n){
    let total =0
    for (let i=1 ; i <=n; i++){
        total += i
    }
    return total
}
```
이렇게 작동하게 되면 연산은 우선 +를 한정해서 계산했을때에는 한번이다.

하지만 이 경우 Loop안에 있기 때문에 말이 조금 달라지는데 우리가 루프를 무한히 돌린다고 했을때

무한히 돌리는 행동을 n개수라고 생각해보자. 이 경우에는 **연산이 무한 즉 n번이 이루어지는것**이다.

물론 이후에 `=`연산자도 동작하기 때문에 갯수가 더 늘어난다. 

또한 loop안에 `++`연산자도 있기 때문에 총 2개의 연산이 n 개수에 따라서 늘어나게 된다.

그리고 `tatal =0` 이라는 것도 한번의 연산이다.

다음으로 `let i =1` 도 한번의 연산이다.

다음으로 `비교연산자(<=)` 도 한번의 연산이다. 

총 5n +2의 연산이 일어난 것이다.

사실 근데 정확한 숫자가 중요한 것은 아니다.

5n+2 이든지 3n 이든지 상관이 없다 우리는 전체적인 추세를 보기 위해서 이것을 하는 것이기 떄문이다. 

위와 같은 루프의 경우 n의 값이 커질때마다. 시간이 비례해서 올라가는 것을 살펴볼 수 있을 것입니다. 

# 빅오 용어 진짜 설명

빅오는 대략적으로 숫자를 세는 것의 붙인 공식이름 정식으로 입력된 값이 늘어남에 따라 얼마나 실행시간이 늘어나는지 보는것입니다.

아까 루프의 시간을 보는게 빅오라고 생각하면 된다. 

O(f(n)) =  N이 커질수록 컴퓨터가 상수 곱하기 f(n)보다 간단히 연산을 덜 해야한다면 그 알고리즘을 O(f(n))이라고 표현한다는 것 

예제 

N이 커져도 실행시간에는 아무 영향도 받지 않는다면 단순하게 1이라고 표현한다.(f(n)=1)

n이라는 값이 입력되는 펑션이 있고, 출력이 존재한다면(f(n)=n)
 
또 이떄 실행 시간이 N의 제곱일 수도 있거나, 상수일수도 있다.(f(n)=n) 

입력과 실행시간의 상관관계를 말해준다. 

아니면 **완전히 다른 관계도 존재한다.**

우리가 짚고 가야할 점은 **빅오를 애기할때는 실행시간이 갖을 수 있는 최대치를 말해야 한다는 것**

즉 일반적로 가장 높은 실행시간을 이야기 한다는 것이다. 

예를들어

```js
function addUpTo(n){
    return n* (n+1) /2
}
```
이 경우는 실행시간이 항상 상수이다. 왜냐하면 언제나 연산이 3개이기 때문

이럴 때는 **O(1)**이라고 표현한다. 이 표기법의 의미는 n의 값이 커진다고 해도, 실행시간이 변하지 않는다는 것이다. 

표현방법은 O(1,N,N^2, n log n) 등이 있다. 

아직 보지도 못한 것들이 써있을 수 있다.

하지만 다음 함수를 한번 보자.

```js
function addUpTo(n){
    var total =0
    for( var i=0;i<=n;i++){
        total +=i
    }
    return total
}
```
이 경우 연산의 갯수는 n이 커질수록 실행시간이 1:1비율로 늘어나고 실질적으로 실행 시간은 n과 연관이 있다.

O(n)으로 표기 할 수 있다.

자 이제 단순화 하는 규칙에 대해서 배워보자.

예제를 통해 먼저 살펴보자

```js
function countUpAndDown(n) {
    console.log("Going up!")
    for (let i =0;i <n;i++){
        console.log(i)
    }
    console.log("At the top!`\nGoing down...")
    for (let j =n-1;j>=0;j--){
        console.log(j)
    }
    console.log("Back down. Bye!")
}
```
