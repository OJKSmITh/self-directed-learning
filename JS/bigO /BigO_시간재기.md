# 7. big O 로 시간재기

```js
function dd(n) {
    let total = 0;
    for (let i = 1; i <= n; i++) {
        total += i
    }
    return total
}

console.log(dd(100))

function addUpTo2(n) {
    return n * (n + 1) / 2
}
console.log(addUpTo2(100))
```

이 두 코드를 비교하면 어떻게 되는가? 

여기서 더 나은것은 무엇인가? 

1. 속도가 빠른것으로 해야하는가요?
2. 메모리를 적게 쓰는걸로?
3. 만들어지는 변수의 갯수, 함수 호출시 저장되는것
4. 코드를 얼마나 쉽게 읽을 수 있는가?  -> 코드 적은 코드 쓰기 

아니면 이런 모든 점을 다 고려해보고 조화를 이루어야 한다., 하지만 상황마다 다르다.

보통 중요시 되는것은 1,2 번이다.

하지만 우리는 우선은 속도를 평가하는 것에 집중해야 한다.

속도를 측정하는 가장 편한 방법은 내장되어 있는 타이밍 펑션 사용하는 것이다. addUpTo


1. 타이밍 펑션
```js

function addUpTo(n) {
    let total = 0;
    for (let i = 1; i <= n; i++) {
        total += i
    }
    return total
}

let t1 = performance.now()
addUpTo(1000000000)
let t2 = performance.now()
console.log(`Time Elapsed : ${(t2 - t1) / 1000} seconds`)
```

이런 방법이 가장 좋은 방법이 아니지만 일일히 하는 방법중 하나임

이 방법에는 기기마다 다른 방법으로 시간을 잰다는 것과, 기계에 다른 무엇인가가 실행될때등 다양한 문제가 있다.

언제나 다른 시간이 적용된다는 것이 단점이다.

위 코드도 매번 다른 시간이 나오기 때문에 **완전히 믿을수 없다는 단점**이 있다.

그럼 이제 어떤 개념을 사용해야 할까요?

정확한 시간을 초로 계산하는 것보다 **연산 갯수**를 세면 된다.

ex) 알고리즘을 7개를 해야 한다면, 결국 그 7개에 시간이 걸리게 되는 것 

```js
function addUpTo(n){
    return n * (n+1) /2
}
```
위의 코드의 경우 곱셈 하나, 덧셈 하나, 나눗셈 하나가 존재한다. 이러한 행위 하나 하나를 연산개수로 친다. 

**계산(연산)은 딱 3번 이루어진다**.

```js
function addUpTo(n){
    let total =0
    for (let i=1 ; i <=n; i++){
        total += i
    }
    return total
}
```
이렇게 작동하게 되면 연산은 우선 +를 한정해서 계산했을때에는 한번이다.

하지만 이 경우 Loop안에 있기 때문에 말이 조금 달라지는데 우리가 루프를 무한히 돌린다고 했을때

무한히 돌리는 행동을 n개수라고 생각해보자. 이 경우에는 **연산이 무한 즉 n번이 이루어지는것**이다.

물론 이후에 `=`연산자도 동작하기 때문에 갯수가 더 늘어난다. 

또한 loop안에 `++`연산자도 있기 때문에 총 2개의 연산이 n 개수에 따라서 늘어나게 된다.

그리고 `tatal =0` 이라는 것도 한번의 연산이다.

다음으로 `let i =1` 도 한번의 연산이다.

다음으로 `비교연산자(<=)` 도 한번의 연산이다. 

총 5n +2의 연산이 일어난 것이다.

사실 근데 정확한 숫자가 중요한 것은 아니다.

5n+2 이든지 3n 이든지 상관이 없다 우리는 전체적인 추세를 보기 위해서 이것을 하는 것이기 떄문이다. 

위와 같은 루프의 경우 n의 값이 커질때마다. 시간이 비례해서 올라가는 것을 살펴볼 수 있을 것입니다. 

# 8. 빅오 용어 진짜 설명

빅오는 대략적으로 숫자를 세는 것의 붙인 공식이름 정식으로 입력된 값이 늘어남에 따라 얼마나 실행시간이 늘어나는지 보는것입니다.

아까 루프의 시간을 보는게 빅오라고 생각하면 된다. 

O(f(n)) =  N이 커질수록 컴퓨터가 상수 곱하기 f(n)보다 간단히 연산을 덜 해야한다면 그 알고리즘을 O(f(n))이라고 표현한다는 것 

예제 

N이 커져도 실행시간에는 아무 영향도 받지 않는다면 단순하게 1이라고 표현한다.(f(n)=1)

n이라는 값이 입력되는 펑션이 있고, 출력이 존재한다면(f(n)=n)
 
또 이떄 실행 시간이 N의 제곱일 수도 있거나, 상수일수도 있다.(f(n)=n) 

입력과 실행시간의 상관관계를 말해준다. 

아니면 **완전히 다른 관계도 존재한다.**

우리가 짚고 가야할 점은 **빅오를 애기할때는 실행시간이 갖을 수 있는 최대치를 말해야 한다는 것**

즉 일반적로 가장 높은 실행시간을 이야기 한다는 것이다. 

예를들어

```js
function addUpTo(n){
    return n* (n+1) /2
}
```
이 경우는 실행시간이 항상 상수이다. 왜냐하면 언제나 연산이 3개이기 때문

이럴 때는 **O(1)**이라고 표현한다. 이 표기법의 의미는 n의 값이 커진다고 해도, 실행시간이 변하지 않는다는 것이다. 

표현방법은 O(1,N,N^2, n log n) 등이 있다. 

아직 보지도 못한 것들이 써있을 수 있다.

하지만 다음 함수를 한번 보자.

```js
function addUpTo(n){
    var total =0
    for( var i=0;i<=n;i++){
        total +=i
    }
    return total
}
```
이 경우 연산의 갯수는 n이 커질수록 실행시간이 1:1비율로 늘어나고 실질적으로 실행 시간은 n과 연관이 있다.

O(n)으로 표기 할 수 있다.

자 이제 단순화 하는 규칙에 대해서 배워보자.

예제를 통해 먼저 살펴보자

```js
function countUpAndDown(n) {
    console.log("Going up!")
    for (let i =0;i <n;i++){
        console.log(i)
    }
    console.log("At the top!`\nGoing down...")
    for (let j =n-1;j>=0;j--){
        console.log(j)
    }
    console.log("Back down. Bye!")
}
```
n이 늘어날 수록 루프안에 연산이 있다 이는 O(n) 이다.

밑에도 똑같이 O(n)이 존재한다. 

그렇기 때문에 O(n)이 두개가 있을거라고 생각하지만

O(n)이라고만 표시하면 된다. 

왜냐하면 우리는 시간소요 경향을 살펴보는것이기 때문이다.

다른 예제를 한번 더 보자

```js
function printAllParis(n){
    for (var i=0;i <n; i++){
        for(var j=0; j<n;j++){
            console.log(i,j)
        }
    }
}
```
이 경우도 아까와 같이 O(n) 두개가 아니냐 라고 생각할 수 있습니다. 왜냐하면 똑같이 n이 커질수록 이곳은 실행시간이 n제곱의 값으로 늘어나기 때문입니다.

중첩되어 있기 때문입니다. 이를 O(n^2) 이라고 합니다. 이 그래프의 추세는 O(n)과는 조금 다른 추세가 나타납니다. 

# 9. 빅오 표기법 간단하게 하기

모든 연산을 다 세는건 힘들고, 결국 우리에게 중요한건 전체적인 추세가 중요함

n이 커질수록 실행시간도 비례하게 늘어나기 때문에 5n+2든 100n이든 상관이 없기 때문

이렇게 O(n)을 찾는 좋은 방법(규칙)들이 존재한다. 

경험에 바탕을 둔 방법들이다.

1. 대략적으로 정확한 큰 그림 찾기 , 상수는 중요하지 않다! , **상수는 지워버리기**
2. 작은 연산도 중요하지 않다, 작은 연산은 다 지워버려!! (+,-) /
3.  n^2 부터는 간단하지 않다. **가장 빠르거나, 느린걸 쓰면된다**

1. 산수는 상수라는것(덧셈, 뺄셈, 곱셈, 나눗셈), n의 값과 상관없음 2+2/ 100만 +2
2. 변수배정도 상수이다. 변수에 값을 할당하는 시간도 다 비슷하다.
3. 인덱스를 이용하여 배열 엘리먼트를 접근하는것 배열에서 첫번쨰를 찾던, 10번쨰를 찾건 비슷하다. 이것도 실행시간이 상수이다. 
4. 루프가 있으면복잡도가 루프의 길이 곱하기, 루프 안에 있는 연산들 리스트에 있는 데이터를 루프로 처리할떄 n이 커질수록 루프가 반복되는 횟수가 반복됨


ex) 
```js 
function logAtLeaset5(n){
    for (var i=1; i<=Math.max(5,n); i++){
        console.log(i)
    }
}
```
이 함수는 10을 입력하면 호출을 10번합니다. 

하지만 1을 입력하면 5까지 출력합니다. 

3을 입력해도 5까지 나오고

하지만 7을 입력하면 7까지 나옵니다.

이걸 어떻게 빅오로 표기할 것인가?

n이 1000만이면 이 루프는 천만번 돌것이다.

따라서 O(n)이다.

반대의 경우도 한번 살펴보자

```js
function logAtLeast5(n){
    for(var i=1; i<= Math.min(5,n); i++){
        console.log(i)
    }
}
```
이 경우 30을 입력하면 5번만 나오고, 3을 입력하면 3까지만 나온다.

이떄 주의점은 양수만 된다는 것

중요한것은 n이 커져도 아무 영향을 주지 않는다는 것이다.

n이 1000이 더라도 5번만 된다.

루프는 5를 넘을 수 없기 때문에 O(1)로 나타낸다 = O(5)

빅오 좋은 순위

# 10. 공간복잡도

공간복잡도란? 

여태까지는 알고리즘이 얼마나 빨리 실행되는지에 목적을 두고 있었습니다. 입력이 커질수록 알고리즘이 얼마나 많은 공간을 차지하는지에 대해서 배웠습니다.

공간복잡도도 마찬가지로 빅오표기법을 통해서 얼마나 많은 메모리가 필요한지 표기할 수도 있지만 이제는 공간, 사용되는 메모리에 집중하겠습니다.

몇가지 기본적인 것을 짚고 넘어갑시다.

당연히 n이 커질수록 무한대까지 가면서 입력 자체가 커진다는 것입니다. 

보조 공간 복잡도 : 입력되는 것을 제외, 알고리즘 자체가 필요로 하는 공간

오늘은 이것에 대해서 배웁시다.

우리는 알고리즘 자체를 파악하려고 지금 이것을 하기 때문입니다. 따라서 n 이 커질수록 입력이 커진다고 가정합시다. 입력이 차지하는 공간은 괜찮습니다. 

알고리즘 자체가 어떤 영향을 주는지 살펴봅시다.

**별도로 언급하지 않는한 이제 공간 복잡도는 보조 공간 복잡도에 대해서 다루는 것입니다.** 

- 기본 규칙
1. **불대수, 숫자, undefined, null**은 자바스크립트에서 모두 **불변 공간**입니다.
2. 문자열은 O(n) 공간이 필요합니다. 만약 n이 50이라면 문자열은 길이가 1자인 문자열보다 50배의 공간을 갖습니다.
   
   reference타입, 배열, 객체도 같습니다. 대부분 O(n)이라고 생각하면 됩니다

```js
function sum(arr){
    let total =0
    for( let i =0; i<arr.length;i++){
        total += arr[i]
    }
    return total
}
```
sum이라는 이 펑션은 배열을 받아서 그 배열 안에 있는 모든 아이템을 합할 것입니다. 

여기서 이 함수는 공간을 얼마나 차지할까요?

우선 배열의 길이와는 상관없이 total이라는 변수가 하나 존재합니다. 이는 한 숫자입니다.

루프를 반복하면서 i =0입니다. 또 하나의 숫자입니다. 그렇게 차지하는 숫자는 끝입니다. 

루프가 돌아도 결국 공간은 두개만 존재합니다. 

**입력의 크기가 차지하는 공간과는 아무 상관이 없습니다.**

total 변수에 더하기만 할뿐 새로운 변수를 만들지는 않습니다.  그렇다면 결국 상수 공간이 존재하는 것이빈다. O(1) 공간이 존재할 뿐입니다. 

```js
function double(arr){
    let newArr = []
    for( let i=0; i <arr.length; i++){
        newArr.push(2* arr[i])
    }
    return newArr
}
```
이렇게 할 경우 아이템이 계속 추가되는 배열이 나오게 됩니다. 즉 새로운 배열이라는 것입니다. 

그렇다면 **배열의 크기가 늘어나서 무한대에 가까워지면 공간복잡도는 어떻게 됩니까?**

어떤 상황에서도 새로운 배열을 만드는 코드가 있습니다.

배열이 입력과 비례해서 길어지는 것과 비교하면 별로 중요하지는 않습니다.

입력된 배열의 길이가 10이면 새로운 배열에 저장되는 아이템이 10개가 됩니다. 

입력된 배열의 길이가 50이면 새로운 배열에 저장하는 아이템이 50개가 되어 배열을 리턴합니다. 

즉 n numbers O(n)을 차지합니다. 

# 11. 로그와 섹션 요약

어떤 알고리즘들은 o(1),o(n), o(n^2) 처럼 간단하지 않을 수 있기 때문에 로그방식이 나왔다.

빅오표기들 중 어렵거나 덜 흔한 수학개념들이 등장하고, 그 중 자주 나오는게 로그이다.

로그란 무엇인가?

로그함수는 지수함수의 역함입니다.

나눗셈과 곱셈이 짝인 것처럼 로그함수와 지수함수는 짝입니다..

이 부분은 노트필기


# 13. 빅오표기법, 시간과 공간 복잡성, 코드 성능 분석을 토대로 알고 있는 지식에 적용해봅시다.

기본적인 자바스크립트

빅오 시점에서 오브젝트와 배열이 어떻게 작용하는가

배열에 데이터를 입력하는데 빠른 방법이 있고, 아닌 방법이 있는지 


# 14. 객체안의 빅오

객체 

정렬되어 있지 않은 데이터 구조 모두 key value 짝을 갖고 있다.

```js
let instructor = {
    firstName: "kelly",
    isInstructor: true,
    favoriteNumbers : [1,2,3,4]
}
```

예를 들어 이 객체 리터럴에는 instructor라는 변수에 key value 3개가 저장되어 있다. 

객체는 정렬되어 있을 필요가 없을 때 좋다.

빠른 접근, 삽입, 그리고 삭제에 좋다.

- 객체의 빅오
1. 삽입 : O(1)
2. 삭제 : O(1)
3. 탐색: O(n)
4. 접근: O(1)

아무것도 정렬할필요가 없다면 객체가 제일 좋은 방법이다. (제일 빠르니까)

우리가 저 위의 isntructor의 변수의 firstName: kelly라고 저장할시에 js는 어떻게 동작하나요?

컴퓨터는 메모리 공간을 다시 바로 접근하는 것이 아니라, 여러가지 부차적인 과정이 필요합니다.

이는 **해싱**과 관련이 있는데 이것은 후에 배울것입니다. 

여기서 제일 중요한 것은 자바스크립트가 **어떤 정보를 객체 안에 상수 시간안에 저장할 수 있다는 것**입니다.

원하는 내용을 상수 시간안에 불어오거나, 수정이 가능하지만 제거하는것과 같습니다. 정렬이 되어있지 않다는 가정하에 아주 빠릅니다.

시작은 있지만 끝이 없기 때문에 어디에 새로운 객체를 입력하든지 상관이 없습니다. 

객체의 시작이나, 중간, 끝에 삽입할 수 업고, 키를 통해서 가능합니다.

탐색은 선형시간인데 이때 탐색 key를 찾는것이 아닙니다. 어떠한 정보를 접근하는 시간은 상수 시간입니다. 

어떤 특정한 정보가 어떤 값에 있는지 확인하는 것, 이쪽에 있는지 쉽게 알 수 있는 방법이 없다.

모든 속성을 확인해야 값을 확인할 수 있다. 

- 객체의 메서드의 빅오 
1. Object.keys - O(n)
2. Object.values -O(n)
3. Object.entries - O(n)
4. hasOwnProperty - O(1)


# 15. 배열안의 데이터에 접근이 느린 이유

배열을 빅오를 통해서 판단해보고 객체와 비교했을때 성능이 어떤지 알아봅시다.

```js
let names = ["Michael","Melissa", "Andrea"]
let values = [trun, {} , [], 2, "awesome"]
```
배열은 뭉치로 있는 객체와는 다릅니다.

정렬되어 있는 것이 필요하다면 유용하지만, 시간이 좀 더 걸립니다 

배열은 대부분 정렬되어 있는 것을 사용하기 위해서 사용합니다. 

정렬되어 있는 것이 필요하더라도 싱글 링크 리스트와, 더블링크 리스트처럼 코드안에 정렬된 구조가 있는 데이터도 있습니다.

선형 리스트 구조이다. 엘리먼트마다 특정한 위치에 있고 순서대로 연결되어 있다.

하지만, 떄로는 하는 작업에 따라서, 배열보다 더 빠를 수 있다. 

정렬되어 있는 데이터 구조가 배열만 있는 것은 아니다.

링크 리스트는 나중에 배울 것

우리는 정렬되어 있는 데이터가 필요할 때 배열을 사용할 수 있지만, 성능을 희생해야 할 수도 있다. 

특히 입력과 제거를 할때 그렇다. 

배열에 있는 데이터를 접근하는것은 아주 빠르다.

- 배열의 빅오
1. 추가 : 배열에 따라 다름
2. 삭제 : 배열에 따라 다름
3. 탐색 : O(n)
4. 접근: O(1) -> 객체와 같음

접근은 이름들이 있는 배열이 있다면 2번째 이름을 원한다면 그저 상수시간만큼만 걸린다는 것입니다. 

배열은 엘리먼트마다 지름길이 있다. 실제로 있는 인덱스라면 배열의 길이와 상관없이 바로 접근한다. 

만약 엘리먼트를 추가하고 싶다면 끝에다 추가한다면, push를 통해서 상수시간이 걸린다. 

배열끝에 추가하고 인덱스를 추가하면 다를게 없다.

문제가 되는 것들은 배열 앞에 추가할때이다. 왜냐하면 인덱스들이 엉망이 되기 때문이다. 



